



[TOC]



# Java内存区域



## 概述



jdk8之后的内存区域划分为如下所示。其中栈和程序计数器是线程私有的，其他则为共享内存区域。

![memory](images\memory.png)

## 虚拟机栈

虚拟机栈记录的是线程的现场信息，只不过这部分现场信息是java的。现场保存的是线程执行栈的**栈帧**，每一个方法对应一个栈帧，每个栈帧记录了局部变量表、操作数栈、动态链接和返回地址等信息。

- 局部变量表

保存了方法体内的局部变量的值，这部分是线程安全的。

- 返回地址

当被调用的方法返回后，从栈帧中的返回地址指示虚拟机从哪里继续执行代码。

## 本地方法栈

类似虚拟机栈。不过是native方法的部分的描述。

## 程序计数器

这个计数器可以理解为指针，在内存中记录了当前线程执行字节码的位置；在线程被唤醒后恢复继续执行工作。

## 堆

**堆是垃圾收集器管理的内存区域。**这部分使我们java程序员关注的重点部分，因为我们要定位一些内存问题并对此进行调优。

堆的划分，要根据JVM选择的收集器来决定如何划分。所以这部分的划分可以留到收集器部分来具体说明。



## 方法区

在JDK1.8之前，hotspot虚拟机设计团队把方法区设计为永久代的一部分，便于统一进行内存管理。1.8之后方法区的由直接内存进行管理，方法区用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 运行时常量池

存放编译器生成的各种字母变量和符号引用。注意这里和文件常量的区别，其本省具有动态性，比如String.intern()  



## 直接内存

可以使用DirectByteBuffer等类进行直接内存的分配，如果直接内存使用不当，也会出现内存溢出的情况。



## 对象是如何在内存中分配的（todo）



1. 检测类有没有被加载到内存中，如果没有则加载

2. 分配内存。由于类加载后虚拟机便能确定对象需要的内存大小，这里有两种内存分配方式：

   a.指针碰撞

   b.空闲列表(CMS)

   分配内存会出现竞争问题，一种是采用同步机制，一种采用TLAB的方式；TLAB可以通过-XX:+/-UseTLAB参数设定

3. 初始化内存空间的数据区为0。这里就会涉及到一个问题，比如我们设计一个业务bean对象的字段，是使用Integer好还是int好，如果是Integer那么字段值为null，如果Int因为对象的初始化机制都会设为0，有些情况下会出现歧义。

4. **对象头**的初始化

5. 执行构造函数。初始化对象的字段等信息

## 参考文档



https://www.cnblogs.com/czwbig/p/11127124.html



# 收集器



# 常见问题定位



## CPU飙升



Jstack -l pid

 

查看堆栈信息，此堆栈信息中会有线程id,16进制

 

根据top -H -p pid查看各个线程cpu时间占比，接着查看占用线程cpu时间高的线程堆栈信息，查看线程状态，堆栈日志可参看：

 

https://www.cnblogs.com/kabi/p/5169383.html

 

gc评率太高结合jps -v查看jvm的内存回收机制。如果内存确实满了，那么可以查看是哪些对象占用了大量的内存导致gc频繁？可以通过jmap -histro pid查看哪些java对象占用了较大内存？

 

Iftop

 

ipstat

## 内存溢出及泄露